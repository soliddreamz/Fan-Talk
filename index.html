<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#061026" />

  <title>Fan Talk</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="icon-180.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png" />

  <style>
    :root{
      --bg1:#061026;
      --bg2:#020814;
      --card: rgba(255,255,255,0.06);
      --card2: rgba(255,255,255,0.04);
      --text: #eaf1ff;
      --muted: rgba(234,241,255,0.78);
      --muted2: rgba(234,241,255,0.55);
      --blue1:#3b82f6;
      --blue2:#2563eb;
      --shadow: rgba(0,0,0,0.45);
      --radius: 28px;
    }

    html, body { height: 100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 20% 0%, #0e2a66 0%, var(--bg1) 35%, var(--bg2) 100%);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 20px;
    }

    .wrap{
      width: min(520px, 92vw);
    }

    .panel{
      background: linear-gradient(180deg, var(--card), var(--card2));
      border-radius: var(--radius);
      box-shadow: 0 24px 60px var(--shadow);
      padding: 26px 22px 22px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      text-align:center;
    }

    /* Logo at top (replaces Fan Talk text) */
    .brandLogo{
      width: min(220px, 70vw);
      height: auto;
      margin: 0 auto 14px;
      display:block;
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.35));
    }

    .subtitle{
      margin: 8px auto 18px;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.35;
      max-width: 440px;
    }

    /* Fan visual (BACK TO FAN IMAGE, NOT LOGO) */
    .fanWrap{
      width: 140px;
      height: 140px;
      margin: 18px auto 18px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .fanImg{
      width: 120px;
      height: 120px;
      display:block;
      animation: spin 1.4s linear infinite;
      filter: drop-shadow(0 12px 22px rgba(0,0,0,0.45));
      user-select:none;
      -webkit-user-drag:none;
    }

    @keyframes spin { from{transform:rotate(0deg);} to{transform:rotate(360deg);} }

    /* Buttons */
    .btnRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 4px;
      justify-items: stretch;
    }

    button{
      appearance:none;
      border:none;
      border-radius: 16px;
      padding: 14px 14px;
      font-size: 16px;
      color: white;
      background: linear-gradient(180deg, var(--blue1), var(--blue2));
      box-shadow: 0 14px 30px rgba(37,99,235,0.35);
      cursor:pointer;
    }

    button.secondary{
      background: rgba(255,255,255,0.07);
      color: var(--text);
      box-shadow: none;
      border: 1px solid rgba(255,255,255,0.08);
    }

    button:disabled{
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow:none;
    }

    button:active{ transform: scale(0.98); }

    .controls{
      margin-top: 14px;
      padding: 14px 14px 10px;
      background: rgba(0,0,0,0.15);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.06);
    }

    label{
      display:block;
      margin-top: 10px;
      margin-bottom: 6px;
      color: var(--muted);
      font-size: 13px;
      letter-spacing: 0.2px;
    }

    select, input[type="range"]{
      width: 100%;
      max-width: 420px;
      margin: 0 auto;
      display:block;
    }

    select{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
      color: var(--text);
      outline:none;
    }

    input[type="range"]{
      accent-color: var(--blue1);
    }

    .status{
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      min-height: 18px;
    }

    .fineprint{
      margin-top: 10px;
      color: var(--muted2);
      font-size: 11px;
    }

    /* Recording pulse on Record button */
    .recordingPulse{
      animation: pulse 1s infinite;
    }
    @keyframes pulse{
      0%{ box-shadow: 0 0 0 0 rgba(59,130,246,0.65), 0 14px 30px rgba(37,99,235,0.35); }
      70%{ box-shadow: 0 0 0 18px rgba(59,130,246,0), 0 14px 30px rgba(37,99,235,0.35); }
      100%{ box-shadow: 0 0 0 0 rgba(59,130,246,0), 0 14px 30px rgba(37,99,235,0.35); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">

      <!-- Logo TOP (replaces Fan Talk text) -->
      <img class="brandLogo" src="logo.png" alt="Fan Talk" />

      <div class="subtitle">
        Talk into the mic like you're talking through a fan. Record ‚Üí stop ‚Üí play or download.
      </div>

      <!-- Fan is BACK and uses icon-192.png -->
      <div class="fanWrap">
        <img id="fanImg" class="fanImg" src="icon-192.png" alt="Fan" />
      </div>

      <div class="btnRow">
        <button id="recordBtn">üéô Record</button>
        <button id="stopBtn" class="secondary" disabled>‚ñ† Stop</button>
        <button id="playBtn" class="secondary" disabled>‚ñ∂ Play</button>
        <button id="downloadBtn" class="secondary" disabled>‚¨á Download WAV</button>
      </div>

      <div class="controls">
        <label for="preset">Preset</label>
        <select id="preset">
          <option value="slow">Slow Fan ‚Äî Nostalgic</option>
          <option value="medium" selected>Medium Fan ‚Äî Classic</option>
          <option value="fast">Fast Fan ‚Äî Buzz</option>
        </select>

        <label for="sensitivity">Fan Speed (Sensitivity)</label>
        <input id="sensitivity" type="range" min="0" max="100" value="45" />
      </div>

      <div id="status" class="status">Ready.</div>
      <div class="fineprint">On-device audio only. Nothing uploaded unless you export.</div>
    </div>
  </div>

<script>
/**
 * Fan Talk ‚Äî stable single-file build
 * - Fan reacts to voice level during recording
 * - Applies ‚Äúfan‚Äù effect to the recorded audio (flutter + filtered + mild grit)
 * - Protects against distortion (compressor + safe gain + soft clip)
 * - Exports WAV
 */

let mediaRecorder = null;
let chunks = [];
let rawArrayBuffer = null;
let processedWavUrl = null;
let processedAudioBuffer = null;

const recordBtn = document.getElementById("recordBtn");
const stopBtn = document.getElementById("stopBtn");
const playBtn = document.getElementById("playBtn");
const downloadBtn = document.getElementById("downloadBtn");
const presetEl = document.getElementById("preset");
const sensitivityEl = document.getElementById("sensitivity");
const statusEl = document.getElementById("status");
const fanImg = document.getElementById("fanImg");

let meterAnimId = null;
let meterAudioCtx = null;
let analyser = null;
let meterData = null;
let meterSource = null;
let meterStream = null;

// Base fan spin durations (seconds per rotation)
const baseSpin = {
  slow: 2.7,
  medium: 1.4,
  fast: 0.65
};

// -------------------- UI helpers --------------------
function setStatus(t){ statusEl.textContent = t; }

function setFanSpinSeconds(sec){
  // Clamp to keep it reasonable
  const s = Math.max(0.18, Math.min(6.0, sec));
  fanImg.style.animationDuration = s + "s";
}

presetEl.addEventListener("change", () => {
  // Keep fan stable when not recording; during recording it will be driven by voice
  const p = presetEl.value;
  setFanSpinSeconds(baseSpin[p]);
});

// Init
setFanSpinSeconds(baseSpin[presetEl.value]);

// -------------------- Recording + Level meter --------------------
recordBtn.addEventListener("click", async () => {
  try{
    // iOS needs user gesture to allow mic, so this is ok here
    meterStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  }catch(e){
    setStatus("Mic permission denied. Enable mic in Safari settings.");
    return;
  }

  chunks = [];
  rawArrayBuffer = null;
  processedAudioBuffer = null;
  if (processedWavUrl){ URL.revokeObjectURL(processedWavUrl); processedWavUrl = null; }

  // MediaRecorder
  try{
    mediaRecorder = new MediaRecorder(meterStream);
  }catch(e){
    setStatus("Recording not supported in this browser.");
    return;
  }

  mediaRecorder.ondataavailable = (ev) => {
    if (ev.data && ev.data.size > 0) chunks.push(ev.data);
  };

  mediaRecorder.onstop = async () => {
    setStatus("Processing‚Ä¶");
    // stop meter animation
    stopMeter();

    const blob = new Blob(chunks, { type: chunks[0]?.type || "audio/webm" });
    rawArrayBuffer = await blob.arrayBuffer();

    // Decode + process + encode WAV
    try{
      processedAudioBuffer = await makeFanEffectBuffer(rawArrayBuffer);
      const wavBytes = audioBufferToWav(processedAudioBuffer);
      const wavBlob = new Blob([wavBytes], { type: "audio/wav" });
      processedWavUrl = URL.createObjectURL(wavBlob);

      playBtn.disabled = false;
      downloadBtn.disabled = false;
      setStatus("Recorded. Tap Play or Download.");
    }catch(err){
      console.error(err);
      setStatus("Processing failed. Try again.");
    }
  };

  mediaRecorder.start();
  startMeter(meterStream);

  recordBtn.disabled = true;
  stopBtn.disabled = false;
  playBtn.disabled = true;
  downloadBtn.disabled = true;

  recordBtn.classList.add("recordingPulse");
  setStatus("Recording‚Ä¶");
});

stopBtn.addEventListener("click", () => {
  if (!mediaRecorder) return;
  try{
    mediaRecorder.stop();
  }catch(e){}
  // stop the stream tracks
  if (meterStream){
    meterStream.getTracks().forEach(t => t.stop());
  }
  recordBtn.disabled = false;
  stopBtn.disabled = true;
  recordBtn.classList.remove("recordingPulse");
});

playBtn.addEventListener("click", async () => {
  if (!processedAudioBuffer) return;

  // play via AudioContext so it‚Äôs consistent
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  await ctx.resume();
  const src = ctx.createBufferSource();
  src.buffer = processedAudioBuffer;
  src.connect(ctx.destination);
  src.start();
});

downloadBtn.addEventListener("click", () => {
  if (!processedWavUrl) return;
  const a = document.createElement("a");
  a.href = processedWavUrl;
  a.download = "fan-talk.wav";
  document.body.appendChild(a);
  a.click();
  a.remove();
});

// -------------------- Voice-reactive fan meter --------------------
function startMeter(stream){
  stopMeter();

  meterAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  meterAudioCtx.resume();

  analyser = meterAudioCtx.createAnalyser();
  analyser.fftSize = 256;
  meterData = new Uint8Array(analyser.frequencyBinCount);

  meterSource = meterAudioCtx.createMediaStreamSource(stream);
  meterSource.connect(analyser);

  const loop = () => {
    analyser.getByteTimeDomainData(meterData);

    // RMS volume
    let sum = 0;
    for (let i=0;i<meterData.length;i++){
      const v = (meterData[i] - 128) / 128;
      sum += v*v;
    }
    const rms = Math.sqrt(sum / meterData.length); // ~0..1

    // Sensitivity maps how strongly voice changes speed
    const sens = Number(sensitivityEl.value) / 100; // 0..1

    const p = presetEl.value;
    const base = baseSpin[p]; // seconds per rotation
    // Lower seconds = faster spin
    const boost = 1 + (rms * 10 * (0.25 + sens)); // 1..(a few)
    const target = base / boost;

    setFanSpinSeconds(target);

    meterAnimId = requestAnimationFrame(loop);
  };
  loop();
}

function stopMeter(){
  if (meterAnimId) cancelAnimationFrame(meterAnimId);
  meterAnimId = null;

  if (meterAudioCtx){
    try{ meterAudioCtx.close(); }catch(e){}
  }
  meterAudioCtx = null;
  analyser = null;
  meterData = null;
  meterSource = null;

  // restore base fan speed
  setFanSpinSeconds(baseSpin[presetEl.value]);
}

// -------------------- Audio processing: ‚Äúfan talk‚Äù effect --------------------
async function makeFanEffectBuffer(arrayBuffer){
  // Decode
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  await ctx.resume();
  const inputBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));

  // Offline render so Play/Download are stable
  const sr = inputBuffer.sampleRate;
  const length = inputBuffer.length;
  const off = new OfflineAudioContext(inputBuffer.numberOfChannels, length, sr);

  const src = off.createBufferSource();
  src.buffer = inputBuffer;

  // PRE-FILTER: remove rumble & harsh highs
  const hp = off.createBiquadFilter();
  hp.type = "highpass";
  hp.frequency.value = 140;

  const lp = off.createBiquadFilter();
  lp.type = "lowpass";
  lp.frequency.value = 5200;

  // ‚ÄúFan flutter‚Äù = modulated delay
  const delay = off.createDelay(0.05);
  delay.delayTime.value = 0.012;

  const lfo = off.createOscillator();
  const lfoGain = off.createGain();

  const preset = presetEl.value;
  // flutter speed by preset
  const flutterHz = preset === "fast" ? 18 : preset === "slow" ? 8 : 12;
  lfo.frequency.value = flutterHz;

  // flutter depth by sensitivity
  const sens = Number(sensitivityEl.value) / 100; // 0..1
  lfoGain.gain.value = 0.0025 + (sens * 0.007); // small or it distorts

  lfo.connect(lfoGain);
  lfoGain.connect(delay.delayTime);

  // mild grit (soft waveshaper) ‚Äî keeps ‚Äúfan‚Äù buzz without destroying audio
  const shaper = off.createWaveShaper();
  shaper.curve = makeSoftClipCurve(220);
  shaper.oversample = "4x";

  // Blend wet/dry
  const dry = off.createGain();
  const wet = off.createGain();

  // Wet mix by preset (slow = less, fast = more)
  const wetMix = preset === "fast" ? 0.55 : preset === "slow" ? 0.35 : 0.45;
  wet.gain.value = wetMix;
  dry.gain.value = 1 - wetMix;

  // Fan ‚Äútone‚Äù coloring
  const fanBand = off.createBiquadFilter();
  fanBand.type = "bandpass";
  fanBand.frequency.value = preset === "fast" ? 1200 : preset === "slow" ? 700 : 950;
  fanBand.Q.value = 0.8;

  // Anti-distortion protection
  const comp = off.createDynamicsCompressor();
  comp.threshold.value = -18;
  comp.knee.value = 18;
  comp.ratio.value = 4;
  comp.attack.value = 0.008;
  comp.release.value = 0.18;

  const outGain = off.createGain();
  outGain.gain.value = 0.92; // safe headroom

  // Routing:
  // src -> hp -> split to dry and wet
  src.connect(hp);

  // dry path
  hp.connect(dry);

  // wet path: hp -> delay(mod) -> band -> shaper -> lp -> wet
  hp.connect(delay);
  delay.connect(fanBand);
  fanBand.connect(shaper);
  shaper.connect(lp);
  lp.connect(wet);

  // mix -> compressor -> out
  const mix = off.createGain();
  dry.connect(mix);
  wet.connect(mix);

  mix.connect(comp);
  comp.connect(outGain);
  outGain.connect(off.destination);

  // Start
  src.start(0);
  lfo.start(0);
  src.stop(inputBuffer.duration);
  lfo.stop(inputBuffer.duration);

  const rendered = await off.startRendering();
  try{ ctx.close(); }catch(e){}
  return rendered;
}

function makeSoftClipCurve(amount){
  // Soft clip curve: keeps ‚Äúbuzz‚Äù without harsh digital crackle
  const n = 44100;
  const curve = new Float32Array(n);
  const k = typeof amount === "number" ? amount : 200;
  for (let i=0; i<n; i++){
    const x = (i * 2) / n - 1;
    curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
  }
  return curve;
}

// -------------------- WAV export --------------------
function audioBufferToWav(buffer){
  const numCh = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const length = buffer.length;

  // interleave
  const channels = [];
  for (let ch=0; ch<numCh; ch++){
    channels.push(buffer.getChannelData(ch));
  }

  const interleaved = new Float32Array(length * numCh);
  let idx = 0;
  for (let i=0; i<length; i++){
    for (let ch=0; ch<numCh; ch++){
      interleaved[idx++] = channels[ch][i];
    }
  }

  // 16-bit PCM
  const bytesPerSample = 2;
  const blockAlign = numCh * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = interleaved.length * bytesPerSample;

  const bufferOut = new ArrayBuffer(44 + dataSize);
  const view = new DataView(bufferOut);

  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + dataSize, true);
  writeString(view, 8, "WAVE");
  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numCh, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, "data");
  view.setUint32(40, dataSize, true);

  // PCM samples
  let offset = 44;
  for (let i=0; i<interleaved.length; i++){
    let s = Math.max(-1, Math.min(1, interleaved[i]));
    // convert float to 16-bit
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    offset += 2;
  }

  return bufferOut;
}

function writeString(view, offset, str){
  for (let i=0; i<str.length; i++){
    view.setUint8(offset + i, str.charCodeAt(i));
  }
}
</script>
</body>
</html>
