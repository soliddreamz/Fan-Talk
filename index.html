<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fan Talk</title>

  <!-- PWA -->
  <meta name="theme-color" content="#061026" />
  <link rel="manifest" href="manifest.json?v=1" />
  <link rel="apple-touch-icon" href="icon-180.png?v=1" />
  <link rel="icon" sizes="192x192" href="icon-192.png?v=1" />
  <link rel="icon" sizes="512x512" href="icon-512.png?v=1" />

  <style>
    :root{
      --bg1:#050b18;
      --bg2:#07153a;
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.04);
      --text: #e9f2ff;
      --muted: rgba(233,242,255,.72);
      --btn1:#3b82f6;
      --btn2:#2563eb;
      --btnOff: rgba(255,255,255,.10);
      --shadow: rgba(0,0,0,.45);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      background: radial-gradient(1200px 900px at 50% 0%, var(--bg2), var(--bg1));
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 20px;
    }

    .card{
      width:min(520px, 92vw);
      background: linear-gradient(180deg, var(--card), var(--card2));
      border-radius: 26px;
      padding: 22px 18px 16px;
      box-shadow: 0 24px 60px var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      text-align:center;
    }

    .logoWrap{
      display:flex;
      justify-content:center;
      margin: 4px 0 12px;
    }
    .logo{
      width: min(240px, 70vw);
      height:auto;
      display:block;
      image-rendering: auto;
    }

    .subtitle{
      margin: 6px auto 16px;
      max-width: 40ch;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.35;
    }

    /* FAN VISUAL (this is a real fan, not your logo) */
    .fanStage{
      display:flex;
      justify-content:center;
      margin: 10px 0 16px;
    }
    .fanHalo{
      width: 168px;
      height: 168px;
      border-radius: 999px;
      background:
        radial-gradient(circle at 50% 50%,
          rgba(59,130,246,.30) 0%,
          rgba(59,130,246,.12) 40%,
          rgba(59,130,246,.06) 62%,
          rgba(255,255,255,.05) 72%,
          rgba(255,255,255,.00) 100%);
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow:
        0 18px 40px rgba(0,0,0,.25),
        inset 0 0 0 2px rgba(255,255,255,.06);
    }

    .fan{
      width: 132px;
      height: 132px;
      border-radius: 999px;
      background: radial-gradient(circle at 50% 50%, rgba(255,255,255,.08), rgba(255,255,255,.02));
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,.08),
        inset 0 -10px 30px rgba(0,0,0,.22);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }

    .grill{
      position:absolute;
      inset:-10px;
      opacity:.22;
      background:
        radial-gradient(circle at 50% 50%, transparent 60%, rgba(255,255,255,.18) 61%, transparent 62%),
        repeating-radial-gradient(circle at 50% 50%,
          rgba(255,255,255,.10) 0px,
          rgba(255,255,255,.10) 2px,
          transparent 3px,
          transparent 8px);
      pointer-events:none;
    }

    .blades{
      width: 78px;
      height: 78px;
      position:relative;
      transform: rotate(0deg);
      will-change: transform;
    }
    .blade{
      position:absolute;
      left:50%;
      top:50%;
      width: 18px;
      height: 52px;
      transform-origin: 50% 90%;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(96,165,250,.95), rgba(37,99,235,.55));
      filter: drop-shadow(0 2px 6px rgba(0,0,0,.25));
    }
    .blade:nth-child(1){ transform: translate(-50%,-92%) rotate(0deg); }
    .blade:nth-child(2){ transform: translate(-50%,-92%) rotate(72deg); }
    .blade:nth-child(3){ transform: translate(-50%,-92%) rotate(144deg); }
    .blade:nth-child(4){ transform: translate(-50%,-92%) rotate(216deg); }
    .blade:nth-child(5){ transform: translate(-50%,-92%) rotate(288deg); }

    .hub{
      position:absolute;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(255,255,255,.22);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.14);
    }

    /* Controls */
    .btnRow{
      display:flex;
      gap: 10px;
      justify-content:center;
      flex-wrap:wrap;
      margin: 12px 0 8px;
    }
    button{
      border:none;
      color:white;
      font-weight:600;
      padding: 12px 16px;
      border-radius: 14px;
      min-width: 140px;
      background: linear-gradient(135deg, var(--btn1), var(--btn2));
      box-shadow: 0 10px 22px rgba(37,99,235,.25);
      cursor:pointer;
    }
    button.secondary{
      background: rgba(255,255,255,.10);
      box-shadow:none;
      color: rgba(233,242,255,.92);
    }
    button:disabled{
      opacity:.45;
      cursor:not-allowed;
    }

    .panel{
      margin-top: 10px;
      background: rgba(0,0,0,.16);
      border-radius: 18px;
      padding: 12px 12px 10px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.05);
      text-align:left;
    }
    .label{
      font-size: 12px;
      color: rgba(233,242,255,.70);
      margin: 6px 2px 6px;
    }
    select, input[type="range"]{
      width:100%;
    }
    select{
      background: rgba(255,255,255,.10);
      color: var(--text);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px 10px;
      outline:none;
    }

    input[type="range"]{
      accent-color: #60a5fa;
    }

    .status{
      margin-top: 8px;
      font-size: 13px;
      color: rgba(233,242,255,.75);
      text-align:center;
      min-height: 18px;
    }
    footer{
      margin-top: 10px;
      font-size: 11px;
      color: rgba(233,242,255,.55);
      text-align:center;
    }

    /* Recording pulse */
    .recordingGlow{
      animation: glow 1s infinite;
    }
    @keyframes glow{
      0%{ box-shadow: 0 0 0 0 rgba(59,130,246,.55); }
      70%{ box-shadow: 0 0 0 18px rgba(59,130,246,0); }
      100%{ box-shadow: 0 0 0 0 rgba(59,130,246,0); }
    }
  </style>
</head>

<body>
  <div class="card">
    <!-- LOGO: replaces the "Fan Talk" TEXT at the top -->
    <div class="logoWrap">
      <img class="logo" src="logo.png?v=1" alt="Fan Talk" />
    </div>

    <div class="subtitle">
      Talk into the mic like you're talking through a fan. Record â†’ stop â†’ play or download.
    </div>

    <!-- FAN stays a fan (NOT the logo) -->
    <div class="fanStage">
      <div class="fanHalo" id="fanHalo">
        <div class="fan" aria-hidden="true">
          <div class="grill"></div>
          <div class="blades" id="blades">
            <div class="blade"></div><div class="blade"></div><div class="blade"></div><div class="blade"></div><div class="blade"></div>
          </div>
          <div class="hub"></div>
        </div>
      </div>
    </div>

    <div class="btnRow">
      <button id="recordBtn">ðŸŽ™ Record</button>
      <button id="stopBtn" class="secondary" disabled>â–  Stop</button>
    </div>
    <div class="btnRow">
      <button id="playBtn" class="secondary" disabled>â–¶ Play</button>
      <button id="downloadBtn" class="secondary" disabled>â¬‡ Download WAV</button>
    </div>

    <div class="panel">
      <div class="label">Preset</div>
      <select id="preset">
        <option value="slow">Slow Fan â€” Nostalgic</option>
        <option value="medium" selected>Medium Fan â€” Classic</option>
        <option value="fast">Fast Fan â€” Buzz</option>
      </select>

      <div class="label" style="margin-top:10px;">Fan Speed (Sensitivity)</div>
      <input id="sensitivity" type="range" min="0.6" max="3.0" step="0.05" value="1.4" />
    </div>

    <div class="status" id="status">Ready.</div>
    <footer>On-device audio only. Nothing uploaded unless you download/export.</footer>
  </div>

<script>
/**
 * Fan Talk â€” locked layout:
 * - Logo only at top (replacing text)
 * - Fan is a real fan graphic and responds to voice level
 * - Distortion fixed by gain staging + compressor/limiter when rendering output
 */

const recordBtn = document.getElementById('recordBtn');
const stopBtn = document.getElementById('stopBtn');
const playBtn = document.getElementById('playBtn');
const downloadBtn = document.getElementById('downloadBtn');
const presetSel = document.getElementById('preset');
const sensitivity = document.getElementById('sensitivity');
const statusEl = document.getElementById('status');

const bladesEl = document.getElementById('blades');
const fanHalo = document.getElementById('fanHalo');

let micStream = null;
let mediaRecorder = null;
let chunks = [];
let rawAudioBuffer = null;     // decoded mic recording
let processedBuffer = null;    // effected output
let processedWavBlob = null;
let processedUrl = null;

let meterCtx = null;
let analyser = null;
let rafId = null;

// ===== FAN VISUAL: spin speed driven by mic loudness =====
let baseRPM = 80;           // baseline rotation when idle
let currentRPM = baseRPM;
let angle = 0;
let lastTs = performance.now();

function presetToBaseRPM(preset){
  if (preset === 'slow') return 60;
  if (preset === 'fast') return 120;
  return 80; // medium
}

function animateFan(ts){
  const dt = Math.max(0.001, (ts - lastTs) / 1000);
  lastTs = ts;

  // If we have analyser, compute level
  let level = 0;
  if (analyser){
    const data = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(data);
    // RMS
    let sum = 0;
    for (let i=0;i<data.length;i++){
      const v = (data[i]-128)/128;
      sum += v*v;
    }
    const rms = Math.sqrt(sum / data.length);
    // Normalize & sensitivity
    const sens = parseFloat(sensitivity.value);
    level = Math.min(1, rms * 6.5 * sens); // tuned for speech
  }

  // Target RPM = base + reaction
  const target = baseRPM + level * 520;
  // Smooth (critically damp-ish)
  currentRPM += (target - currentRPM) * (1 - Math.pow(0.001, dt));

  // Rotate: rpm -> deg/sec
  const degPerSec = (currentRPM / 60) * 360;
  angle = (angle + degPerSec * dt) % 360;
  bladesEl.style.transform = `rotate(${angle}deg)`;

  // subtle halo response
  const glow = 0.22 + level * 0.55;
  fanHalo.style.boxShadow = `0 18px 40px rgba(0,0,0,.25), inset 0 0 0 2px rgba(255,255,255,.06), 0 0 40px rgba(59,130,246,${glow})`;

  rafId = requestAnimationFrame(animateFan);
}

presetSel.addEventListener('change', ()=>{
  baseRPM = presetToBaseRPM(presetSel.value);
});

// ===== RECORDING =====
async function startMeter(stream){
  // separate context just for meter; no processing
  meterCtx = new (window.AudioContext || window.webkitAudioContext)();
  const source = meterCtx.createMediaStreamSource(stream);
  analyser = meterCtx.createAnalyser();
  analyser.fftSize = 2048;
  source.connect(analyser);
  if (!rafId){
    lastTs = performance.now();
    rafId = requestAnimationFrame(animateFan);
  }
}

async function stopMeter(){
  if (rafId){
    cancelAnimationFrame(rafId);
    rafId = null;
  }
  analyser = null;
  if (meterCtx){
    try{ await meterCtx.close(); }catch(e){}
    meterCtx = null;
  }
}

function setStatus(msg){
  statusEl.textContent = msg;
}

recordBtn.addEventListener('click', async () => {
  try{
    processedBuffer = null;
    processedWavBlob = null;
    if (processedUrl){
      URL.revokeObjectURL(processedUrl);
      processedUrl = null;
    }
    playBtn.disabled = true;
    downloadBtn.disabled = true;

    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

    await startMeter(micStream);

    // Record raw mic via MediaRecorder
    chunks = [];
    const options = {};
    // Safari iOS supports audio/mp4; Chrome supports webm/opus
    if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
      options.mimeType = 'audio/webm;codecs=opus';
    } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
      options.mimeType = 'audio/mp4';
    }
    mediaRecorder = new MediaRecorder(micStream, options);
    mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };

    mediaRecorder.onstop = async () => {
      try{
        setStatus('Processing fan soundâ€¦');
        // decode recorded audio
        const blob = new Blob(chunks, { type: mediaRecorder.mimeType || 'audio/webm' });
        const arrayBuf = await blob.arrayBuffer();
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        rawAudioBuffer = await ctx.decodeAudioData(arrayBuf.slice(0));

        // render processed audio offline to avoid real-time glitches
        processedBuffer = await renderFanEffect(rawAudioBuffer, presetSel.value);
        processedWavBlob = bufferToWav(processedBuffer);
        processedUrl = URL.createObjectURL(processedWavBlob);

        playBtn.disabled = false;
        downloadBtn.disabled = false;

        setStatus('Recorded. Tap Play or Download.');
        try{ await ctx.close(); }catch(e){}
      }catch(err){
        console.error(err);
        setStatus('Could not process audio. Try recording again.');
      }
    };

    mediaRecorder.start();
    recordBtn.disabled = true;
    stopBtn.disabled = false;
    recordBtn.classList.add('recordingGlow');
    setStatus('Recordingâ€¦');
  }catch(err){
    console.error(err);
    setStatus('Mic blocked. Enable microphone permission and try again.');
  }
});

stopBtn.addEventListener('click', async () => {
  try{
    stopBtn.disabled = true;
    recordBtn.disabled = false;
    recordBtn.classList.remove('recordingGlow');
    setStatus('Stoppingâ€¦');

    if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
    if (micStream){
      micStream.getTracks().forEach(t=>t.stop());
      micStream = null;
    }
    await stopMeter();
    // keep fan idling
    analyser = null;
    if (!rafId){
      baseRPM = presetToBaseRPM(presetSel.value);
      lastTs = performance.now();
      rafId = requestAnimationFrame(animateFan);
    }
    setStatus('Processingâ€¦');
  }catch(e){
    console.error(e);
    setStatus('Stopped.');
  }
});

playBtn.addEventListener('click', async () => {
  if (!processedUrl) return;
  const audio = new Audio(processedUrl);
  audio.play();
});

downloadBtn.addEventListener('click', () => {
  if (!processedUrl) return;
  const a = document.createElement('a');
  a.href = processedUrl;
  a.download = 'fan-talk.wav';
  a.click();
});

// start idle fan
baseRPM = presetToBaseRPM(presetSel.value);
lastTs = performance.now();
rafId = requestAnimationFrame(animateFan);

// ===== FAN EFFECT RENDERING (fix distortion) =====
async function renderFanEffect(inputBuffer, preset){
  const sr = inputBuffer.sampleRate;
  const length = inputBuffer.length;
  const channels = Math.min(2, inputBuffer.numberOfChannels);

  const offline = new OfflineAudioContext(channels, length, sr);

  // Source
  const src = offline.createBufferSource();
  src.buffer = inputBuffer;

  // --- Gain staging (prevents distortion) ---
  const pre = offline.createGain();
  pre.gain.value = 0.55; // reduce level before effects

  // "Fan" bandpass + subtle saturation (waveshaper) + amplitude flutter (ring mod)
  const band = offline.createBiquadFilter();
  band.type = 'bandpass';
  band.frequency.value = 900;
  band.Q.value = 0.8;

  const high = offline.createBiquadFilter();
  high.type = 'highpass';
  high.frequency.value = 120;

  const low = offline.createBiquadFilter();
  low.type = 'lowpass';
  low.frequency.value = 5200;

  // Ring-mod style flutter using LFO on a gain node
  const flutterGain = offline.createGain();
  flutterGain.gain.value = 0.9;

  const lfo = offline.createOscillator();
  lfo.type = 'sine';

  const lfoDepth = offline.createGain();
  lfoDepth.gain.value = 0.18; // flutter amount

  // Presets: adjust flutter rate + band emphasis
  if (preset === 'slow'){
    lfo.frequency.value = 14;
    band.frequency.value = 780;
    band.Q.value = 0.9;
    lfoDepth.gain.value = 0.14;
  } else if (preset === 'fast'){
    lfo.frequency.value = 32;
    band.frequency.value = 1100;
    band.Q.value = 0.75;
    lfoDepth.gain.value = 0.22;
  } else {
    lfo.frequency.value = 22;
    band.frequency.value = 900;
    band.Q.value = 0.8;
    lfoDepth.gain.value = 0.18;
  }

  // LFO drives flutterGain.gain around 0.9
  const lfoBias = offline.createConstantSource();
  lfoBias.offset.value = 0.88;

  lfo.connect(lfoDepth);
  lfoDepth.connect(flutterGain.gain);
  lfoBias.connect(flutterGain.gain);

  // Waveshaper (soft clip) to add "fan grit" but controlled
  const shaper = offline.createWaveShaper();
  shaper.curve = makeSoftClipCurve(0.9);
  shaper.oversample = '4x';

  // Compressor / limiter to stop output clipping (this fixes â€œdistorted overallâ€)
  const comp = offline.createDynamicsCompressor();
  comp.threshold.value = -22;
  comp.knee.value = 18;
  comp.ratio.value = 6;
  comp.attack.value = 0.006;
  comp.release.value = 0.13;

  const post = offline.createGain();
  post.gain.value = 1.15;

  // Chain: src -> pre -> band -> hp -> lp -> flutter -> shaper -> comp -> post -> out
  src.connect(pre);
  pre.connect(band);
  band.connect(high);
  high.connect(low);
  low.connect(flutterGain);
  flutterGain.connect(shaper);
  shaper.connect(comp);
  comp.connect(post);
  post.connect(offline.destination);

  lfo.start(0);
  lfoBias.start(0);
  src.start(0);

  const rendered = await offline.startRendering();
  return rendered;
}

function makeSoftClipCurve(amount){
  // amount: 0..1 (lower = softer)
  const n = 44100;
  const curve = new Float32Array(n);
  const k = 2 + amount * 18;
  for (let i=0;i<n;i++){
    const x = (i*2)/n - 1;
    curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
  }
  return curve;
}

// ===== WAV export =====
function bufferToWav(audioBuffer){
  const numCh = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const length = audioBuffer.length;

  // interleave
  const interleaved = new Float32Array(length * numCh);
  for (let ch=0; ch<numCh; ch++){
    const data = audioBuffer.getChannelData(ch);
    for (let i=0; i<length; i++){
      interleaved[i*numCh + ch] = data[i];
    }
  }

  // 16-bit PCM
  const bytesPerSample = 2;
  const blockAlign = numCh * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = interleaved.length * bytesPerSample;

  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numCh, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, dataSize, true);

  let offset = 44;
  for (let i=0;i<interleaved.length;i++){
    let s = Math.max(-1, Math.min(1, interleaved[i]));
    // convert float to 16-bit PCM
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    offset += 2;
  }

  return new Blob([buffer], { type: 'audio/wav' });
}

function writeString(view, offset, str){
  for (let i=0;i<str.length;i++){
    view.setUint8(offset+i, str.charCodeAt(i));
  }
}
</script>
</body>
</html>
