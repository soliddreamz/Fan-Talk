<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fan Talk</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#07142b" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="apple-touch-icon" href="icon-180.png" />
  <link rel="icon" sizes="192x192" href="icon-192.png" />
  <link rel="icon" sizes="512x512" href="icon-512.png" />

  <style>
    :root{
      --bg1:#0b1a3a;
      --bg2:#040913;
      --card: rgba(255,255,255,0.06);
      --text:#eaf1ff;
      --muted: rgba(234,241,255,0.78);
      --btn1:#3b82f6;
      --btn2:#2563eb;
      --btnDark:#15223a;
      --shadow: rgba(0,0,0,0.35);
      --spinDur: 1.4s; /* updated live */
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      min-height:100vh;
      color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",system-ui,sans-serif;
      background: radial-gradient(circle at top, var(--bg1), var(--bg2));
      display:flex;
      justify-content:center;
      padding: 18px 14px 28px;
    }

    /* subtle nostalgic screen texture */
    body::after{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      background:
        radial-gradient(circle at center, transparent 58%, rgba(0,0,0,0.38)),
        repeating-linear-gradient(to bottom,
          rgba(255,255,255,0.02),
          rgba(255,255,255,0.02) 1px,
          transparent 2px,
          transparent 5px
        );
      mix-blend-mode: overlay;
      opacity:0.9;
    }

    .wrap{
      width: min(520px, 100%);
      padding-top: 8px;
    }

    .card{
      width:100%;
      background: var(--card);
      border-radius: 22px;
      box-shadow: 0 26px 70px var(--shadow);
      padding: 18px 18px 16px;
      text-align:center;
      backdrop-filter: blur(8px);
    }

    /* LOGO replaces title text */
    .topLogo{
      display:block;
      margin: 6px auto 10px;
      width: min(260px, 78vw);
      height:auto;
    }

    .subtitle{
      margin: 0 auto 10px;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.35;
      max-width: 420px;
    }

    /* FAN AREA (this is NOT the logo) */
    .fanStage{
      margin: 18px auto 14px;
      display:flex;
      justify-content:center;
      align-items:center;
    }

    .fanSvg{
      width: 150px;
      height: 150px;
      display:block;
      filter: drop-shadow(0 12px 25px rgba(0,0,0,0.35));
    }

    /* spin only the blades group */
    .blades{
      transform-origin: 50% 50%;
      animation: spin var(--spinDur) linear infinite;
    }

    @keyframes spin{
      from{ transform: rotate(0deg); }
      to{ transform: rotate(360deg); }
    }

    /* CONTROLS */
    .row{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top: 6px;
    }

    button{
      border:none;
      border-radius: 16px;
      padding: 14px 16px;
      color:white;
      font-size: 16px;
      min-width: 150px;
      background: linear-gradient(135deg, var(--btn1), var(--btn2));
      box-shadow: 0 10px 30px rgba(59,130,246,0.35);
      transform: translateZ(0);
    }
    button.secondary{
      background: rgba(21,34,58,0.75);
      box-shadow: none;
    }
    button:disabled{ opacity:0.45; }
    button:active{ transform: scale(0.98); }

    .controls{
      margin-top: 10px;
    }

    select, input[type="range"]{
      width: min(420px, 92%);
      margin: 10px auto 0;
      display:block;
    }

    .label{
      margin-top: 12px;
      font-weight: 700;
      opacity: 0.9;
    }

    .status{
      margin-top: 10px;
      font-size: 14px;
      color: var(--muted);
    }

    footer{
      margin-top: 10px;
      font-size: 11px;
      color: rgba(234,241,255,0.62);
    }

    .recordingGlow{
      box-shadow: 0 0 0 0 rgba(59,130,246,0.55);
      animation: pulse 1.1s ease-out infinite;
    }
    @keyframes pulse{
      0%{ box-shadow: 0 0 0 0 rgba(59,130,246,0.55); }
      70%{ box-shadow: 0 0 0 18px rgba(59,130,246,0); }
      100%{ box-shadow: 0 0 0 0 rgba(59,130,246,0); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">

      <!-- LOGO replaces the "Fan Talk" title text -->
      <img class="topLogo" src="logo.png" alt="Fan Talk" />

      <p class="subtitle">
        Talk into the mic like you're talking through a fan. Press RECORD, speak, stop ‚Äî then apply a fan preset and download.
      </p>

      <!-- Fan stays here (not the logo) -->
      <div class="fanStage" aria-label="Fan animation">
        <svg class="fanSvg" viewBox="0 0 200 200" role="img">
          <!-- outer ring -->
          <circle cx="100" cy="100" r="70" fill="none" stroke="rgba(170,200,255,0.25)" stroke-width="8"/>
          <circle cx="100" cy="100" r="62" fill="none" stroke="rgba(170,200,255,0.15)" stroke-width="3"/>

          <!-- blades group spins -->
          <g class="blades">
            <path d="M100 40 C118 46, 126 66, 110 78 C102 84, 92 84, 86 78 C72 66, 80 46, 100 40Z" fill="#2f7cf6"/>
            <path d="M160 100 C154 118, 134 126, 122 110 C116 102, 116 92, 122 86 C134 72, 154 80, 160 100Z" fill="#2f7cf6"/>
            <path d="M100 160 C82 154, 74 134, 90 122 C98 116, 108 116, 114 122 C128 134, 120 154, 100 160Z" fill="#2f7cf6"/>
            <path d="M40 100 C46 82, 66 74, 78 90 C84 98, 84 108, 78 114 C66 128, 46 120, 40 100Z" fill="#2f7cf6"/>
          </g>

          <!-- hub -->
          <circle cx="100" cy="100" r="10" fill="#9cc1ff"/>
          <circle cx="100" cy="100" r="4" fill="#07142b"/>
        </svg>
      </div>

      <div class="controls">
        <div class="row">
          <button id="recordBtn">üéô Record</button>
          <button id="stopBtn" class="secondary" disabled>‚èπ Stop</button>
        </div>

        <div class="row">
          <button id="playBtn" class="secondary" disabled>‚ñ∂ Play</button>
          <button id="downloadBtn" class="secondary" disabled>‚¨á Download WAV</button>
        </div>

        <div class="label">Preset</div>
        <select id="preset">
          <option value="slow">Slow Fan ‚Äî Nostalgic</option>
          <option value="medium" selected>Medium Fan ‚Äî Classic</option>
          <option value="fast">Fast Fan ‚Äî Buzz</option>
        </select>

        <div class="label">Fan Speed (Sensitivity)</div>
        <input id="sensitivity" type="range" min="1" max="10" step="1" value="6" />

        <div class="status" id="status">Ready.</div>

        <footer>On-device audio only. Nothing uploaded unless you download/export.</footer>
      </div>

    </div>
  </div>

<script>
  let audioContext;
  let mediaRecorder;
  let chunks = [];
  let recordedBuffer = null;

  // voice reactive
  let analyser, dataArray, rafId = null;

  const recordBtn = document.getElementById("recordBtn");
  const stopBtn = document.getElementById("stopBtn");
  const playBtn = document.getElementById("playBtn");
  const downloadBtn = document.getElementById("downloadBtn");
  const preset = document.getElementById("preset");
  const sensitivity = document.getElementById("sensitivity");
  const statusEl = document.getElementById("status");

  function baseSpinSeconds(){
    if (preset.value === "fast") return 0.65;
    if (preset.value === "slow") return 2.6;
    return 1.35; // medium
  }

  function setSpinSeconds(sec){
    document.documentElement.style.setProperty("--spinDur", `${sec}s`);
  }

  // init base speed
  setSpinSeconds(baseSpinSeconds());

  preset.addEventListener("change", () => {
    setSpinSeconds(baseSpinSeconds());
  });

  recordBtn.addEventListener("click", async () => {
    try {
      statusEl.textContent = "Requesting microphone‚Ä¶";

      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (audioContext.state === "suspended") await audioContext.resume();

      // analyser for voice-reactive fan speed
      const mic = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 512;
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      mic.connect(analyser);

      // recorder
      mediaRecorder = new MediaRecorder(stream);
      chunks = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };

      mediaRecorder.onstop = async () => {
        try {
          // stop reactive loop
          if (rafId) cancelAnimationFrame(rafId);
          rafId = null;

          const blob = new Blob(chunks);
          const arrayBuffer = await blob.arrayBuffer();
          recordedBuffer = await audioContext.decodeAudioData(arrayBuffer);

          playBtn.disabled = false;
          downloadBtn.disabled = false;
          statusEl.textContent = "Recorded. Tap Play or Download.";
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Could not process recording.";
        }
      };

      mediaRecorder.start();

      recordBtn.disabled = true;
      stopBtn.disabled = false;
      recordBtn.classList.add("recordingGlow");
      statusEl.textContent = "Recording‚Ä¶ speak into the mic";

      // start reactive loop
      voiceReactiveLoop();

    } catch (err) {
      console.error(err);
      statusEl.textContent = "Mic blocked. Enable microphone permission in Safari settings.";
    }
  });

  stopBtn.addEventListener("click", () => {
    if (!mediaRecorder) return;
    stopBtn.disabled = true;
    recordBtn.classList.remove("recordingGlow");
    statusEl.textContent = "Stopping‚Ä¶";

    try {
      mediaRecorder.stop();
    } catch (e) {
      console.error(e);
    }

    recordBtn.disabled = false;
  });

  playBtn.addEventListener("click", async () => {
    if (!recordedBuffer) return;

    if (audioContext && audioContext.state === "suspended") {
      await audioContext.resume();
    }

    // playback with a tiny ‚Äúfan flutter‚Äù using LFO on playbackRate
    const source = audioContext.createBufferSource();
    source.buffer = recordedBuffer;

    const lfo = audioContext.createOscillator();
    const lfoGain = audioContext.createGain();

    const lfoHz = preset.value === "fast" ? 24 : (preset.value === "slow" ? 8 : 14);
    lfo.frequency.value = lfoHz;
    lfoGain.gain.value = 0.035; // subtle wobble

    lfo.connect(lfoGain);
    lfoGain.connect(source.playbackRate);

    source.connect(audioContext.destination);

    lfo.start();
    source.start();

    source.onended = () => {
      try { lfo.stop(); } catch {}
    };

    statusEl.textContent = "Playing‚Ä¶";
  });

  downloadBtn.addEventListener("click", () => {
    if (!recordedBuffer) return;

    const wavArrayBuffer = audioBufferToWav(recordedBuffer);
    const blob = new Blob([wavArrayBuffer], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "fantalk.wav";
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 2000);
  });

  function voiceReactiveLoop(){
    if (!analyser || !dataArray) return;

    analyser.getByteTimeDomainData(dataArray);

    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const v = (dataArray[i] - 128) / 128;
      sum += v * v;
    }
    const rms = Math.sqrt(sum / dataArray.length); // 0..~1
    const sens = Number(sensitivity.value); // 1..10

    // boost factor based on voice level
    // higher sensitivity => more speed change
    const boost = Math.min(3.2, 1 + rms * (sens * 1.2));

    const base = baseSpinSeconds();
    const newSec = Math.max(0.35, base / boost);

    setSpinSeconds(newSec);

    rafId = requestAnimationFrame(voiceReactiveLoop);
  }

  // WAV encoder
  function audioBufferToWav(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const numFrames = buffer.length;

    const bytesPerSample = 2;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = numFrames * blockAlign;

    const ab = new ArrayBuffer(44 + dataSize);
    const view = new DataView(ab);

    let offset = 0;
    const writeString = (s) => { for (let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); };

    writeString("RIFF");
    view.setUint32(offset, 36 + dataSize, true); offset += 4;
    writeString("WAVE");
    writeString("fmt ");
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, 1, true); offset += 2; // PCM
    view.setUint16(offset, numChannels, true); offset += 2;
    view.setUint32(offset, sampleRate, true); offset += 4;
    view.setUint32(offset, byteRate, true); offset += 4;
    view.setUint16(offset, blockAlign, true); offset += 2;
    view.setUint16(offset, 16, true); offset += 2; // bits
    writeString("data");
    view.setUint32(offset, dataSize, true); offset += 4;

    // interleave
    const channels = [];
    for (let c = 0; c < numChannels; c++) channels.push(buffer.getChannelData(c));

    for (let i = 0; i < numFrames; i++) {
      for (let c = 0; c < numChannels; c++) {
        let sample = channels[c][i];
        sample = Math.max(-1, Math.min(1, sample));
        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
        offset += 2;
      }
    }
    return ab;
  }
</script>

</body>
</html>
