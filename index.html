<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fan Talk</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#0b1020" />
  <link rel="apple-touch-icon" href="icon-180.png" />

  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#071022;
      --card:rgba(255,255,255,0.06);
      --card2:rgba(255,255,255,0.03);
      --text:#eaf1ff;
      --muted:rgba(234,241,255,0.72);
      --blue:#2f7cf6;
      --blue2:#2563eb;
      --shadow:rgba(0,0,0,0.35);
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:radial-gradient(circle at top, #10244b, var(--bg1) 40%, var(--bg2));
      font-family:-apple-system,BlinkMacSystemFont,system-ui,"Segoe UI",sans-serif;
      color:var(--text);
      padding:18px;
    }

    /* subtle nostalgic scanlines */
    body::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(circle at center, transparent 55%, rgba(0,0,0,0.35)),
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.02),
          rgba(255,255,255,0.02) 1px,
          transparent 2px,
          transparent 4px
        );
      mix-blend-mode:overlay;
      opacity:0.9;
    }

    .card{
      width:min(440px, 92vw);
      background:linear-gradient(180deg, var(--card), var(--card2));
      border-radius:26px;
      padding:26px 18px 18px;
      box-shadow:0 18px 50px var(--shadow);
      text-align:center;
      position:relative;
      z-index:1;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    /* Logo replaces the title text */
    .topLogo{
      display:block;
      width:min(220px, 68vw);
      height:auto;
      margin:2px auto 14px;
    }

    .desc{
      margin:0 auto 14px;
      max-width:32ch;
      font-size:14px;
      line-height:1.35;
      color:var(--muted);
    }

    /* FAN (this is the animated fan, NOT logo) */
    .fanWrap{
      margin: 10px auto 16px;
      width:140px;
      height:140px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .fanDisc{
      width:140px;
      height:140px;
      border-radius:50%;
      background:
        radial-gradient(circle at 40% 35%, rgba(255,255,255,0.18), transparent 40%),
        radial-gradient(circle at center, rgba(47,124,246,0.18), rgba(0,0,0,0) 60%),
        rgba(10,18,40,0.35);
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,0.10),
        0 18px 40px rgba(0,0,0,0.35);
      position:relative;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .blades{
      width:92px;
      height:92px;
      position:absolute;
      border-radius:50%;
      animation: spin 1.4s linear infinite;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.25));
    }

    /* blades drawn with 4 petals */
    .blades::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(circle at center, rgba(255,255,255,0.25) 0 10px, transparent 11px),
        conic-gradient(
          from 0deg,
          rgba(47,124,246,0.0) 0 5%,
          rgba(47,124,246,0.85) 5% 20%,
          rgba(47,124,246,0.0) 20% 30%,
          rgba(47,124,246,0.85) 30% 45%,
          rgba(47,124,246,0.0) 45% 55%,
          rgba(47,124,246,0.85) 55% 70%,
          rgba(47,124,246,0.0) 70% 80%,
          rgba(47,124,246,0.85) 80% 95%,
          rgba(47,124,246,0.0) 95% 100%
        );
      border-radius:50%;
      opacity:0.95;
    }

    .hub{
      width:18px;
      height:18px;
      border-radius:50%;
      background:rgba(255,255,255,0.55);
      box-shadow:0 0 0 6px rgba(47,124,246,0.18);
      position:absolute;
    }

    @keyframes spin { from{transform:rotate(0)} to{transform:rotate(360deg)} }

    /* Controls */
    .btnRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin:10px auto 12px;
      width:min(360px, 92%);
    }

    button{
      border:none;
      border-radius:14px;
      padding:12px 14px;
      font-size:15px;
      color:white;
      background: linear-gradient(180deg, var(--blue), var(--blue2));
      box-shadow:0 10px 26px rgba(47,124,246,0.35);
    }
    button.secondary{
      background: rgba(255,255,255,0.08);
      box-shadow:none;
      color:rgba(234,241,255,0.9);
    }
    button:disabled{ opacity:0.45; }

    .label{
      margin-top: 10px;
      font-size:14px;
      color:rgba(234,241,255,0.85);
      font-weight:600;
    }

    select, input[type="range"]{
      width:min(360px, 92%);
      margin-top:8px;
    }

    .status{
      margin-top:10px;
      font-size:13px;
      color:rgba(234,241,255,0.72);
    }

    footer{
      margin-top:10px;
      font-size:11px;
      color:rgba(234,241,255,0.55);
    }
  </style>
</head>

<body>
  <div class="card">
    <!-- LOGO replaces title text -->
    <img class="topLogo" src="logo.png" alt="Fan Talk logo" />

    <p class="desc">
      Talk into the mic like you're talking through a fan. Press RECORD, speak, stop â€” then apply a fan preset and download.
    </p>

    <!-- FAN stays a fan (not the logo) -->
    <div class="fanWrap">
      <div class="fanDisc" aria-label="fan animation">
        <div class="blades" id="blades"></div>
        <div class="hub"></div>
      </div>
    </div>

    <div class="btnRow">
      <button id="recordBtn">ðŸŽ™ Record</button>
      <button id="stopBtn" class="secondary" disabled>â–  Stop</button>
      <button id="playBtn" class="secondary" disabled>â–¶ Play</button>
      <button id="downloadBtn" class="secondary" disabled>â¬‡ Download WAV</button>
    </div>

    <div class="label">Preset</div>
    <select id="preset">
      <option value="slow">Slow Fan â€” Nostalgic</option>
      <option value="medium" selected>Medium Fan â€” Classic</option>
      <option value="fast">Fast Fan â€” Buzz</option>
    </select>

    <div class="label">Fan Speed (Sensitivity)</div>
    <input id="sensitivity" type="range" min="0.5" max="6" step="0.1" value="2.2" />

    <div class="status" id="status">Ready.</div>

    <footer>
      On-device audio only. Nothing uploaded unless you download/export.
    </footer>
  </div>

<script>
  // ------- Fan Talk: record, playback, wav export + voice-reactive fan -------
  let audioContext;
  let mediaRecorder;
  let chunks = [];
  let recordedBuffer = null;

  let analyser = null;
  let dataArray = null;
  let rafId = null;

  const blades = document.getElementById("blades");
  const recordBtn = document.getElementById("recordBtn");
  const stopBtn = document.getElementById("stopBtn");
  const playBtn = document.getElementById("playBtn");
  const downloadBtn = document.getElementById("downloadBtn");
  const preset = document.getElementById("preset");
  const sensitivity = document.getElementById("sensitivity");
  const statusEl = document.getElementById("status");

  function baseSpinSeconds() {
    if (preset.value === "fast") return 0.6;
    if (preset.value === "slow") return 2.8;
    return 1.4; // medium
  }

  function setFanSeconds(sec) {
    blades.style.animationDuration = sec + "s";
  }

  preset.addEventListener("change", () => {
    setFanSeconds(baseSpinSeconds());
  });

  setFanSeconds(baseSpinSeconds());

  recordBtn.addEventListener("click", async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      await audioContext.resume();

      // analyser for voice level
      const micSource = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      micSource.connect(analyser);

      mediaRecorder = new MediaRecorder(stream);
      chunks = [];

      mediaRecorder.ondataavailable = (e) => chunks.push(e.data);

      mediaRecorder.onstop = async () => {
        // stop animation loop
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;

        // stop tracks
        stream.getTracks().forEach(t => t.stop());

        const blob = new Blob(chunks);
        const arr = await blob.arrayBuffer();

        // decode recorded audio
        recordedBuffer = await audioContext.decodeAudioData(arr);
        playBtn.disabled = false;
        downloadBtn.disabled = false;

        statusEl.textContent = "Recorded. Tap Play or Download.";
        // reset fan speed to base
        setFanSeconds(baseSpinSeconds());
      };

      mediaRecorder.start();
      recordBtn.disabled = true;
      stopBtn.disabled = false;
      playBtn.disabled = true;
      downloadBtn.disabled = true;
      statusEl.textContent = "Recordingâ€¦";

      animateFanToVoice();
    } catch (err) {
      statusEl.textContent = "Mic permission blocked. Enable microphone in browser settings.";
      console.error(err);
    }
  });

  stopBtn.addEventListener("click", () => {
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      mediaRecorder.stop();
      recordBtn.disabled = false;
      stopBtn.disabled = true;
      statusEl.textContent = "Stoppingâ€¦";
    }
  });

  playBtn.addEventListener("click", () => {
    if (!recordedBuffer || !audioContext) return;

    const src = audioContext.createBufferSource();
    src.buffer = recordedBuffer;

    // FAN-ish effect: slight wobble via playback rate LFO
    const lfo = audioContext.createOscillator();
    const lfoGain = audioContext.createGain();

    lfo.frequency.value = preset.value === "fast" ? 25 : (preset.value === "slow" ? 8 : 15);
    lfoGain.gain.value = 0.03;

    lfo.connect(lfoGain);
    lfoGain.connect(src.playbackRate);

    src.connect(audioContext.destination);

    lfo.start();
    src.start();
    src.onended = () => { try { lfo.stop(); } catch(e){} };

    statusEl.textContent = "Playingâ€¦";
  });

  downloadBtn.addEventListener("click", () => {
    if (!recordedBuffer) return;
    const wav = audioBufferToWav(recordedBuffer);
    const blob = new Blob([wav], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "fantalk.wav";
    a.click();

    setTimeout(() => URL.revokeObjectURL(url), 4000);
  });

  function animateFanToVoice() {
    if (!analyser || !dataArray) return;

    analyser.getByteTimeDomainData(dataArray);

    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const v = (dataArray[i] - 128) / 128;
      sum += v * v;
    }

    const rms = Math.sqrt(sum / dataArray.length); // 0..~1
    const sens = parseFloat(sensitivity.value);    // user control
    const boost = Math.min(3.2, 1 + rms * (sens * 6));

    const base = baseSpinSeconds();
    setFanSeconds(base / boost);

    rafId = requestAnimationFrame(animateFanToVoice);
  }

  // WAV encoder
  function audioBufferToWav(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;

    const samples = buffer.length;
    const blockAlign = numChannels * bitDepth / 8;
    const byteRate = sampleRate * blockAlign;
    const dataSize = samples * blockAlign;
    const bufferSize = 44 + dataSize;

    const arrayBuffer = new ArrayBuffer(bufferSize);
    const view = new DataView(arrayBuffer);

    let offset = 0;
    function writeString(str) {
      for (let i = 0; i < str.length; i++) view.setUint8(offset++, str.charCodeAt(i));
    }

    writeString("RIFF");
    view.setUint32(offset, 36 + dataSize, true); offset += 4;
    writeString("WAVE");
    writeString("fmt ");
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, format, true); offset += 2;
    view.setUint16(offset, numChannels, true); offset += 2;
    view.setUint32(offset, sampleRate, true); offset += 4;
    view.setUint32(offset, byteRate, true); offset += 4;
    view.setUint16(offset, blockAlign, true); offset += 2;
    view.setUint16(offset, bitDepth, true); offset += 2;
    writeString("data");
    view.setUint32(offset, dataSize, true); offset += 4;

    // interleave channels
    const channelData = [];
    for (let c = 0; c < numChannels; c++) channelData.push(buffer.getChannelData(c));

    for (let i = 0; i < samples; i++) {
      for (let c = 0; c < numChannels; c++) {
        let sample = channelData[c][i];
        sample = Math.max(-1, Math.min(1, sample));
        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
        offset += 2;
      }
    }

    return arrayBuffer;
  }
</script>
</body>
</html>
