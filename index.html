<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Fan Talk</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#06112a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icon-180.png">

  <style>
    :root{
      --bg1:#071433;
      --bg2:#020815;
      --card:rgba(255,255,255,.06);
      --text:#eaf2ff;
      --muted:rgba(234,242,255,.72);
      --btn1:#3b82f6;
      --btn2:#2563eb;
      --btnOff:rgba(255,255,255,.10);
      --shadow:0 22px 55px rgba(0,0,0,.45);
    }

    html,body{height:100%;}
    body{
      margin:0;
      background: radial-gradient(1200px 900px at 50% -10%, rgba(59,130,246,.22), transparent 60%),
                  radial-gradient(900px 700px at 20% 25%, rgba(16,185,129,.09), transparent 55%),
                  radial-gradient(circle at top, var(--bg1), var(--bg2));
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      color:var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:22px;
    }

    .card{
      width:min(460px, 92vw);
      background:var(--card);
      border-radius:26px;
      box-shadow:var(--shadow);
      border:1px solid rgba(255,255,255,.08);
      padding:24px 22px 18px;
      text-align:center;
      backdrop-filter: blur(10px);
    }

    /* Logo at top replaces the "Fan Talk" text */
    .topLogo{
      display:block;
      margin:4px auto 14px;
      width:min(280px, 72vw);
      height:auto;
    }

    .subtitle{
      margin:0 0 14px;
      color:var(--muted);
      line-height:1.35;
      font-size:15px;
    }

    /* Fan visual */
    .fanWrap{
      display:flex;
      justify-content:center;
      margin:14px 0 18px;
    }
    .fan{
      width:120px;
      height:120px;
      border-radius:50%;
      position:relative;
      background:
        radial-gradient(circle at 50% 50%, rgba(59,130,246,.34), rgba(59,130,246,.06) 55%, rgba(255,255,255,.06) 56%, rgba(255,255,255,.03) 65%, transparent 66%),
        radial-gradient(circle at 50% 50%, rgba(0,0,0,.2), transparent 60%);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 0 35px rgba(59,130,246,.24);
      overflow:hidden;
      transform: translateZ(0);
    }
    .fanCore{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      transform: rotate(0deg);
      will-change: transform;
    }
    .blade{
      position:absolute;
      width:14px;
      height:46px;
      border-radius:999px;
      background: linear-gradient(180deg, rgba(88,160,255,.95), rgba(59,130,246,.55));
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.25));
      transform-origin: 50% 95%;
    }
    .blade:nth-child(1){ transform: rotate(0deg)   translateY(-6px); }
    .blade:nth-child(2){ transform: rotate(90deg)  translateY(-6px); }
    .blade:nth-child(3){ transform: rotate(180deg) translateY(-6px); }
    .blade:nth-child(4){ transform: rotate(270deg) translateY(-6px); }

    .hub{
      position:absolute;
      width:14px;height:14px;border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.85), rgba(255,255,255,.12));
      border:1px solid rgba(255,255,255,.20);
    }

    /* Buttons */
    .row{display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:10px 0 6px;}
    button{
      border:0;
      border-radius:16px;
      padding:14px 16px;
      font-size:16px;
      font-weight:600;
      color:white;
      cursor:pointer;
      min-width:140px;
      background: linear-gradient(135deg,var(--btn1),var(--btn2));
      box-shadow: 0 14px 22px rgba(0,0,0,.25);
    }
    button.secondary{
      background: var(--btnOff);
      color: rgba(234,242,255,.92);
      box-shadow:none;
      border:1px solid rgba(255,255,255,.08);
    }
    button:disabled{
      opacity:.45;
      cursor:not-allowed;
    }

    .controls{
      margin-top:10px;
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.07);
      border-radius:18px;
      padding:12px 12px 10px;
    }
    label{
      display:block;
      margin:10px 0 6px;
      color: rgba(234,242,255,.85);
      font-size:13px;
      font-weight:600;
      letter-spacing:.2px;
    }
    select, input[type="range"]{
      width:100%;
    }
    select{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.08);
      color: var(--text);
      outline:none;
    }

    input[type="range"]{ accent-color:#60a5fa; }

    .status{
      margin-top:10px;
      font-size:13px;
      color: var(--muted);
      min-height:18px;
    }
    footer{
      margin-top:10px;
      font-size:11px;
      color: rgba(234,242,255,.55);
    }
  </style>
</head>

<body>
  <div class="card">

    <!-- LOGO replaces the "Fan Talk" title text -->
    <img class="topLogo" src="logo.png" alt="Fan Talk">

    <p class="subtitle">Talk into the mic like you're talking through a fan. Record ‚Üí stop ‚Üí play or download.</p>

    <!-- FAN stays a fan (not the logo) -->
    <div class="fanWrap">
      <div class="fan" aria-label="Fan">
        <div class="fanCore" id="fanCore">
          <div class="blade"></div>
          <div class="blade"></div>
          <div class="blade"></div>
          <div class="blade"></div>
          <div class="hub"></div>
        </div>
      </div>
    </div>

    <div class="row">
      <button id="recordBtn">üé§ Record</button>
      <button id="stopBtn" class="secondary" disabled>‚èπ Stop</button>
    </div>
    <div class="row">
      <button id="playBtn" class="secondary" disabled>‚ñ∂ Play</button>
      <button id="downloadBtn" class="secondary" disabled>‚¨á Download WAV</button>
    </div>

    <div class="controls">
      <label for="preset">Preset</label>
      <select id="preset">
        <option value="slow">Slow Fan ‚Äî Nostalgic</option>
        <option value="medium" selected>Medium Fan ‚Äî Classic</option>
        <option value="fast">Fast Fan ‚Äî Buzz</option>
      </select>

      <label for="sens">Fan Speed (Sensitivity)</label>
      <input id="sens" type="range" min="0.5" max="3.0" step="0.05" value="1.3">
    </div>

    <div class="status" id="status">Ready.</div>
    <footer>On-device processing. Nothing uploaded.</footer>
  </div>

<script>
(() => {
  // ===== UI =====
  const recordBtn = document.getElementById("recordBtn");
  const stopBtn = document.getElementById("stopBtn");
  const playBtn = document.getElementById("playBtn");
  const downloadBtn = document.getElementById("downloadBtn");
  const statusEl = document.getElementById("status");
  const presetEl = document.getElementById("preset");
  const sensEl = document.getElementById("sens");
  const fanCore = document.getElementById("fanCore");

  // ===== FAN ANIMATION (reacts to voice level) =====
  let fanAngle = 0;
  let fanSpeed = 0.02; // base
  function tickFan(){
    fanAngle += fanSpeed;
    fanCore.style.transform = `rotate(${fanAngle}rad)`;
    requestAnimationFrame(tickFan);
  }
  tickFan();

  // ===== AUDIO STATE =====
  let audioCtx = null;
  let stream = null;
  let mediaRecorder = null;
  let chunks = [];
  let rawBlob = null;
  let processedWavBlob = null;
  let processedUrl = null;

  // For voice level tracking
  let analyser = null;
  let levelRAF = null;

  // ===== Helpers =====
  function setStatus(msg){ statusEl.textContent = msg; }

  function getPresetParams() {
    const v = presetEl.value;
    if (v === "slow")   return { lfoHz: 6.0,  flutter: 0.015, toneHz: 900 };
    if (v === "fast")   return { lfoHz: 17.0, flutter: 0.030, toneHz: 1400 };
    return              { lfoHz: 10.0, flutter: 0.020, toneHz: 1100 }; // medium
  }

  function rmsFromAnalyser(a) {
    const buf = new Uint8Array(a.fftSize);
    a.getByteTimeDomainData(buf);
    let sum = 0;
    for (let i=0;i<buf.length;i++){
      const x = (buf[i] - 128) / 128;
      sum += x*x;
    }
    return Math.sqrt(sum / buf.length); // 0..~1
  }

  function startLevelLoop(){
    const sens = () => parseFloat(sensEl.value);
    const base = () => {
      const p = presetEl.value;
      if (p === "slow") return 0.02;
      if (p === "fast") return 0.05;
      return 0.03;
    };

    const loop = () => {
      if (!analyser) return;
      const level = rmsFromAnalyser(analyser);   // voice level
      const s = sens();
      // map level to speed (safe + smooth)
      fanSpeed = base() + Math.min(0.10, level * 0.18 * s);
      levelRAF = requestAnimationFrame(loop);
    };
    loop();
  }

  function stopLevelLoop(){
    if (levelRAF) cancelAnimationFrame(levelRAF);
    levelRAF = null;
  }

  // ===== WAV Encoding =====
  function encodeWAV(audioBuffer) {
    const numCh = audioBuffer.numberOfChannels;
    const sampleRate = audioBuffer.sampleRate;
    const length = audioBuffer.length;

    // interleave
    const interleaved = new Float32Array(length * numCh);
    const chans = [];
    for (let c=0;c<numCh;c++) chans.push(audioBuffer.getChannelData(c));
    for (let i=0;i<length;i++){
      for (let c=0;c<numCh;c++){
        interleaved[i*numCh + c] = chans[c][i];
      }
    }

    // 16-bit PCM
    const bytesPerSample = 2;
    const blockAlign = numCh * bytesPerSample;
    const buffer = new ArrayBuffer(44 + interleaved.length * bytesPerSample);
    const view = new DataView(buffer);

    function writeString(offset, str){
      for (let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i));
    }
    function floatTo16BitPCM(output, offset, input){
      for (let i=0;i<input.length;i++, offset+=2){
        let s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
    }

    writeString(0, "RIFF");
    view.setUint32(4, 36 + interleaved.length * bytesPerSample, true);
    writeString(8, "WAVE");
    writeString(12, "fmt ");
    view.setUint32(16, 16, true); // PCM chunk size
    view.setUint16(20, 1, true);  // PCM format
    view.setUint16(22, numCh, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true); // bits
    writeString(36, "data");
    view.setUint32(40, interleaved.length * bytesPerSample, true);
    floatTo16BitPCM(view, 44, interleaved);

    return new Blob([view], { type: "audio/wav" });
  }

  // ===== Offline processing to avoid distortion =====
  async function processToWav(raw) {
    const arr = await raw.arrayBuffer();

    // decode
    const tmpCtx = new (window.AudioContext || window.webkitAudioContext)();
    const decoded = await tmpCtx.decodeAudioData(arr.slice(0));
    await tmpCtx.close();

    // Offline render with "fan" effect + limiter (fix distortion)
    const sampleRate = decoded.sampleRate;
    const offline = new OfflineAudioContext(decoded.numberOfChannels, decoded.length, sampleRate);

    const src = offline.createBufferSource();
    src.buffer = decoded;

    // safer input gain (prevents clipping)
    const inGain = offline.createGain();
    inGain.gain.value = 0.75;

    // fan tone shaping (gentle bandpass)
    const bp = offline.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = getPresetParams().toneHz;
    bp.Q.value = 0.9;

    // tremolo (fan flutter)
    const trem = offline.createGain();
    trem.gain.value = 0.55;

    const lfo = offline.createOscillator();
    lfo.type = "sine";
    lfo.frequency.value = getPresetParams().lfoHz;

    const lfoDepth = offline.createGain();
    lfoDepth.gain.value = getPresetParams().flutter; // smaller = less distortion

    // gentle comb-ish feel: short delay + feedback
    const delay = offline.createDelay(0.06);
    delay.delayTime.value = 0.028;

    const feedback = offline.createGain();
    feedback.gain.value = 0.22;

    // mix dry/wet
    const dry = offline.createGain();
    dry.gain.value = 0.78;
    const wet = offline.createGain();
    wet.gain.value = 0.48;

    // limiter / compressor (removes harsh distortion)
    const comp = offline.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.knee.value = 18;
    comp.ratio.value = 8;
    comp.attack.value = 0.003;
    comp.release.value = 0.14;

    // routing
    src.connect(inGain);
    inGain.connect(bp);

    // tremolo modulation: trem.gain = 0.55 + lfo*s
    lfo.connect(lfoDepth);
    lfoDepth.connect(trem.gain);

    bp.connect(trem);

    // dry
    trem.connect(dry);

    // wet delay loop
    trem.connect(delay);
    delay.connect(feedback);
    feedback.connect(delay);
    delay.connect(wet);

    // sum
    const sum = offline.createGain();
    dry.connect(sum);
    wet.connect(sum);

    sum.connect(comp);
    comp.connect(offline.destination);

    lfo.start();
    src.start(0);

    const rendered = await offline.startRendering();
    return encodeWAV(rendered);
  }

  // ===== Recording =====
  recordBtn.addEventListener("click", async () => {
    try {
      // iOS requires user gesture; create ctx here
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: false
        }
      });

      // analyser for fan response
      const source = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      source.connect(analyser);
      startLevelLoop();

      // MediaRecorder records raw mic
      chunks = [];
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = e => { if (e.data.size) chunks.push(e.data); };

      mediaRecorder.onstart = () => {
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        playBtn.disabled = true;
        downloadBtn.disabled = true;
        setStatus("Recording‚Ä¶");
      };

      mediaRecorder.onstop = async () => {
        rawBlob = new Blob(chunks, { type: mediaRecorder.mimeType || "audio/webm" });
        setStatus("Processing fan sound‚Ä¶");

        // stop live mic
        stopLevelLoop();
        if (stream) stream.getTracks().forEach(t => t.stop());
        stream = null;

        // close ctx
        if (audioCtx) { try { await audioCtx.close(); } catch(e){} }
        audioCtx = null;
        analyser = null;

        // process to WAV (fan effect) safely
        processedWavBlob = await processToWav(rawBlob);
        processedUrl = URL.createObjectURL(processedWavBlob);

        playBtn.disabled = false;
        downloadBtn.disabled = false;
        recordBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus("Recorded. Tap Play or Download.");
      };

      mediaRecorder.start();

    } catch (err) {
      console.error(err);
      setStatus("Mic blocked. Enable microphone permission in Safari settings.");
      recordBtn.disabled = false;
      stopBtn.disabled = true;
    }
  });

  stopBtn.addEventListener("click", () => {
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      mediaRecorder.stop();
    }
  });

  playBtn.addEventListener("click", () => {
    if (!processedUrl) return;
    const a = new Audio(processedUrl);
    a.play();
  });

  downloadBtn.addEventListener("click", () => {
    if (!processedUrl) return;
    const a = document.createElement("a");
    a.href = processedUrl;
    a.download = "fan-talk.wav";
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

})();
</script>
</body>
</html>
