<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fan Talk</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">

  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#050914;
      --card:rgba(255,255,255,0.06);
      --card2:rgba(255,255,255,0.10);
      --text:#eaf1ff;
      --muted:rgba(234,241,255,0.75);
      --btn:#2f7cf6;
      --btn2:#1b2a4a;
      --shadow:rgba(0,0,0,0.45);
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      padding:20px 16px 28px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: radial-gradient(circle at top, #1b2a4a, var(--bg2));
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }

    .wrap{
      width:100%;
      max-width:460px;
    }

    .card{
      background: linear-gradient(180deg, var(--card), rgba(255,255,255,0.03));
      border:1px solid rgba(255,255,255,0.10);
      border-radius:20px;
      box-shadow: 0 18px 40px var(--shadow);
      padding:18px 16px 16px;
      overflow:hidden;
    }

    /* Header: logo replaces text */
    .header{
      display:flex;
      justify-content:center;
      align-items:center;
      padding:6px 0 10px;
    }
    .logo{
      max-width:260px;
      width:70%;
      height:auto;
      display:block;
    }

    .subtitle{
      margin:0 0 10px;
      text-align:center;
      color:var(--muted);
      font-size:14px;
      line-height:1.35;
    }

    /* Fan area */
    .fan-area{
      display:flex;
      justify-content:center;
      align-items:center;
      padding:12px 0 8px;
    }

    .fan-shell{
      width:150px;
      height:150px;
      display:flex;
      justify-content:center;
      align-items:center;
      border-radius:24px;
      background: rgba(0,0,0,0.14); /* subtle, not a big ‚Äúcircle background‚Äù */
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 10px 30px rgba(0,0,0,0.30);
    }

    /* Fan SVG */
    .fan-svg{
      width:120px;
      height:120px;
      display:block;
    }

    .spin{
      transform-origin: 50% 50%;
      animation: spin var(--spinDur, 1.4s) linear infinite;
    }

    @keyframes spin{
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:10px 6px 2px;
    }

    .row{
      display:flex;
      gap:10px;
    }

    button{
      flex:1;
      border:none;
      border-radius:14px;
      padding:14px 12px;
      font-size:16px;
      font-weight:700;
      color:#fff;
      background: linear-gradient(180deg, #3b86ff, var(--btn));
      box-shadow: 0 10px 24px rgba(47,124,246,0.35);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    button.secondary{
      background: linear-gradient(180deg, #243a66, var(--btn2));
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
      font-weight:700;
    }
    button:disabled{
      opacity:0.45;
      cursor:not-allowed;
    }
    button:active{ transform: scale(0.98); }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:4px 2px;
    }
    label{
      font-size:12px;
      color:rgba(234,241,255,0.75);
      text-align:left;
    }
    select, input[type="range"]{
      width:100%;
    }
    select{
      background: rgba(0,0,0,0.28);
      color: var(--text);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:12px;
      padding:12px 12px;
      font-size:15px;
      outline:none;
    }
    input[type="range"]{
      accent-color:#79a7ff;
    }

    .status{
      margin-top:6px;
      text-align:center;
      font-size:13px;
      color:rgba(234,241,255,0.72);
      min-height:18px;
    }

    .footer{
      margin-top:10px;
      text-align:center;
      font-size:11px;
      color:rgba(234,241,255,0.55);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">

      <!-- LOGO replaces Fan Talk text -->
      <div class="header">
        <img src="logo.png" class="logo" alt="Fan Talk Logo">
      </div>

      <p class="subtitle">
        Talk into the mic like you‚Äôre talking through a fan. Record, then play the ‚Äúfan voice.‚Äù
      </p>

      <!-- Fan stays a fan (NOT the logo) -->
      <div class="fan-area">
        <div class="fan-shell">
          <svg class="fan-svg" viewBox="0 0 100 100" aria-label="Fan">
            <!-- outer grill -->
            <circle cx="50" cy="50" r="44" fill="none" stroke="rgba(255,255,255,0.22)" stroke-width="4"/>
            <circle cx="50" cy="50" r="34" fill="none" stroke="rgba(255,255,255,0.16)" stroke-width="2"/>

            <!-- spinning blades group -->
            <g id="blades" class="spin">
              <circle cx="50" cy="50" r="6" fill="rgba(255,255,255,0.70)"/>
              <path d="M50 12 C64 22 66 42 54 50 C46 44 42 28 50 12Z" fill="rgba(47,124,246,0.95)"/>
              <path d="M88 50 C78 64 58 66 50 54 C56 46 72 42 88 50Z" fill="rgba(47,124,246,0.90)"/>
              <path d="M50 88 C36 78 34 58 46 50 C54 56 58 72 50 88Z" fill="rgba(47,124,246,0.88)"/>
              <path d="M12 50 C22 36 42 34 50 46 C44 54 28 58 12 50Z" fill="rgba(47,124,246,0.86)"/>
            </g>

            <!-- hub -->
            <circle cx="50" cy="50" r="3.5" fill="rgba(0,0,0,0.35)"/>
          </svg>
        </div>
      </div>

      <div class="controls">
        <div class="row">
          <button id="recordBtn">üéô Record</button>
          <button id="stopBtn" class="secondary" disabled>‚èπ Stop</button>
        </div>

        <div class="row">
          <button id="playBtn" class="secondary" disabled>‚ñ∂ Play</button>
          <button id="downloadBtn" class="secondary" disabled>‚¨á Download</button>
        </div>

        <div class="field">
          <label for="preset">Fan preset</label>
          <select id="preset">
            <option value="slow">Slow Fan ‚Äî Nostalgic</option>
            <option value="medium" selected>Medium Fan ‚Äî Classic</option>
            <option value="fast">Fast Fan ‚Äî Buzz</option>
          </select>
        </div>

        <div class="field">
          <label for="mix">Fan strength (reduce if it sounds too intense)</label>
          <input id="mix" type="range" min="0" max="1" step="0.05" value="0.45">
        </div>

        <div class="status" id="status">Ready.</div>
        <div class="footer">On-device audio. Nothing uploaded.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---- DOM ----
  const recordBtn = document.getElementById("recordBtn");
  const stopBtn = document.getElementById("stopBtn");
  const playBtn = document.getElementById("playBtn");
  const downloadBtn = document.getElementById("downloadBtn");
  const presetEl = document.getElementById("preset");
  const mixEl = document.getElementById("mix");
  const statusEl = document.getElementById("status");
  const blades = document.getElementById("blades");

  // ---- Audio / recording state ----
  let audioCtx = null;
  let mediaRecorder = null;
  let chunks = [];
  let recordedBuffer = null;

  // For live (voice-reactive) fan speed
  let analyser = null;
  let dataArray = null;
  let rafId = null;
  let micStream = null;

  // ---- Helpers ----
  function presetBaseSpinSeconds() {
    const v = presetEl.value;
    if (v === "fast") return 0.70;
    if (v === "slow") return 2.60;
    return 1.35; // medium
  }

  function setSpinSeconds(sec) {
    // CSS custom property controlling animation duration
    blades.style.setProperty("--spinDur", `${sec}s`);
  }

  function setStatus(msg){ statusEl.textContent = msg; }

  // Voice level -> spin speed while recording
  function startVoiceReactiveSpin() {
    if (!analyser || !dataArray) return;

    const base = presetBaseSpinSeconds();

    const tick = () => {
      analyser.getByteTimeDomainData(dataArray);

      // RMS volume
      let sum = 0;
      for (let i=0; i<dataArray.length; i++) {
        const v = (dataArray[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / dataArray.length);

      // Map rms to boost. Keep stable (no crazy jumps)
      const boost = Math.min(3.2, 1 + (rms * 10));
      const sec = Math.max(0.18, base / boost);

      setSpinSeconds(sec);
      rafId = requestAnimationFrame(tick);
    };

    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(tick);
  }

  function stopVoiceReactiveSpin() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    setSpinSeconds(presetBaseSpinSeconds());
  }

  // Convert AudioBuffer to WAV (16-bit PCM)
  function audioBufferToWavBlob(buffer) {
    const numCh = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const length = buffer.length;
    const bytesPerSample = 2;
    const blockAlign = numCh * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = length * blockAlign;
    const totalSize = 44 + dataSize;

    const ab = new ArrayBuffer(totalSize);
    const view = new DataView(ab);

    let offset = 0;
    const writeStr = (s) => { for (let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); };

    writeStr("RIFF");
    view.setUint32(offset, totalSize - 8, true); offset += 4;
    writeStr("WAVE");
    writeStr("fmt ");
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, 1, true); offset += 2; // PCM
    view.setUint16(offset, numCh, true); offset += 2;
    view.setUint32(offset, sampleRate, true); offset += 4;
    view.setUint32(offset, byteRate, true); offset += 4;
    view.setUint16(offset, blockAlign, true); offset += 2;
    view.setUint16(offset, 16, true); offset += 2;
    writeStr("data");
    view.setUint32(offset, dataSize, true); offset += 4;

    // interleave
    const chans = [];
    for (let ch=0; ch<numCh; ch++) chans.push(buffer.getChannelData(ch));

    let pos = 44;
    for (let i=0; i<length; i++) {
      for (let ch=0; ch<numCh; ch++) {
        let sample = Math.max(-1, Math.min(1, chans[ch][i]));
        const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        view.setInt16(pos, int16, true);
        pos += 2;
      }
    }

    return new Blob([view], {type:"audio/wav"});
  }

  // Create the "fan voice" effect for playback (no harsh distortion)
  function playWithFanEffect(buffer) {
    if (!audioCtx) return;
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;

    // Mix control
    const wet = audioCtx.createGain();
    const dry = audioCtx.createGain();
    const out = audioCtx.createGain();
    const mix = Number(mixEl.value); // 0..1
    wet.gain.value = mix;
    dry.gain.value = 1 - mix;

    // Fan tremolo (amplitude modulation)
    const tremGain = audioCtx.createGain();
    tremGain.gain.value = 1.0;

    const lfo = audioCtx.createOscillator();
    const lfoDepth = audioCtx.createGain();

    // LFO frequency depends on preset
    const p = presetEl.value;
    const lfoHz = (p === "fast") ? 24 : (p === "slow") ? 9 : 15;
    lfo.frequency.value = lfoHz;
    lfo.type = "sine";

    // Depth is subtle to avoid ugly distortion
    lfoDepth.gain.value = 0.35; // tremolo depth (safe)
    lfo.connect(lfoDepth);
    lfoDepth.connect(tremGain.gain);

    // Slight tone shaping
    const lp = audioCtx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 9000;

    // Routing: src -> dry -> out
    //       : src -> lp -> trem -> wet -> out
    src.connect(dry).connect(out);
    src.connect(lp).connect(tremGain).connect(wet).connect(out);
    out.connect(audioCtx.destination);

    lfo.start();
    src.start();

    src.onended = () => {
      try { lfo.stop(); } catch(e){}
      lfo.disconnect();
      lfoDepth.disconnect();
    };
  }

  // Offline render the effect into a new AudioBuffer for download (WAV)
  async function renderFanEffectOffline(buffer) {
    const sampleRate = 44100;
    const channels = buffer.numberOfChannels;
    const length = Math.ceil(buffer.duration * sampleRate);
    const offline = new OfflineAudioContext(channels, length, sampleRate);

    const src = offline.createBufferSource();
    src.buffer = buffer;

    const wet = offline.createGain();
    const dry = offline.createGain();
    const out = offline.createGain();
    const mix = Number(mixEl.value);
    wet.gain.value = mix;
    dry.gain.value = 1 - mix;

    const tremGain = offline.createGain();
    tremGain.gain.value = 1.0;

    const lfo = offline.createOscillator();
    const lfoDepth = offline.createGain();
    const p = presetEl.value;
    const lfoHz = (p === "fast") ? 24 : (p === "slow") ? 9 : 15;
    lfo.frequency.value = lfoHz;
    lfo.type = "sine";
    lfoDepth.gain.value = 0.35;
    lfo.connect(lfoDepth);
    lfoDepth.connect(tremGain.gain);

    const lp = offline.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 9000;

    src.connect(dry).connect(out);
    src.connect(lp).connect(tremGain).connect(wet).connect(out);
    out.connect(offline.destination);

    src.start(0);
    lfo.start(0);

    const rendered = await offline.startRendering();
    return rendered;
  }

  // ---- Events ----
  presetEl.addEventListener("change", () => {
    setSpinSeconds(presetBaseSpinSeconds());
  });

  // Initial spin
  setSpinSeconds(presetBaseSpinSeconds());

  recordBtn.addEventListener("click", async () => {
    try {
      // iOS requires AudioContext resume on user gesture
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.resume();

      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

      // Analyzer for voice-reactive spinning
      const mic = audioCtx.createMediaStreamSource(micStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 256;
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      mic.connect(analyser);

      // Recorder
      mediaRecorder = new MediaRecorder(micStream);
      chunks = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };

      mediaRecorder.onstop = async () => {
        try {
          const blob = new Blob(chunks);
          const arrayBuffer = await blob.arrayBuffer();
          recordedBuffer = await audioCtx.decodeAudioData(arrayBuffer);
          playBtn.disabled = false;
          downloadBtn.disabled = false;
          setStatus("Recorded. Tap Play.");
        } catch (err) {
          setStatus("Recording saved, but couldn‚Äôt decode audio.");
        }
      };

      mediaRecorder.start();
      recordBtn.disabled = true;
      stopBtn.disabled = false;
      playBtn.disabled = true;
      downloadBtn.disabled = true;

      setStatus("Recording‚Ä¶");
      startVoiceReactiveSpin();

    } catch (err) {
      setStatus("Mic blocked. In Safari: AA ‚Üí Website Settings ‚Üí Microphone ‚Üí Allow.");
    }
  });

  stopBtn.addEventListener("click", () => {
    try {
      if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
    } catch(e){}

    recordBtn.disabled = false;
    stopBtn.disabled = true;

    stopVoiceReactiveSpin();

    // Stop mic stream tracks to prevent iOS weirdness
    if (micStream) {
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
  });

  playBtn.addEventListener("click", async () => {
    if (!recordedBuffer || !audioCtx) return;
    try {
      await audioCtx.resume();
      setStatus("Playing‚Ä¶");
      playWithFanEffect(recordedBuffer);
      // reset status after a moment (simple)
      setTimeout(() => setStatus("Ready."), Math.min(1500, recordedBuffer.duration * 1000));
    } catch(e){
      setStatus("Could not play audio.");
    }
  });

  downloadBtn.addEventListener("click", async () => {
    if (!recordedBuffer) return;
    try {
      setStatus("Rendering download‚Ä¶");
      const rendered = await renderFanEffectOffline(recordedBuffer);
      const wavBlob = audioBufferToWavBlob(rendered);

      const url = URL.createObjectURL(wavBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "fan-talk.wav";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);

      setStatus("Downloaded.");
      setTimeout(() => setStatus("Ready."), 900);
    } catch(e){
      setStatus("Download failed.");
    }
  });

})();
</script>
</body>
</html>
